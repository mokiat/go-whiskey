// Generated by 'github.com/momchil-atanasov/gostub'

package graphics_stubs

import (
	sync "sync"

	alias1 "github.com/momchil-atanasov/go-whiskey/graphics"
	alias2 "github.com/momchil-atanasov/go-whiskey/math"
)

type Float3UniformStub struct {
	StubGUID            int
	SetValueStub        func(arg1 alias2.Vec3)
	setValueMutex       sync.RWMutex
	setValueArgsForCall []struct {
		arg1 alias2.Vec3
	}
	ValueStub        func() (result1 alias2.Vec3)
	valueMutex       sync.RWMutex
	valueArgsForCall []struct {
	}
	valueReturns struct {
		result1 alias2.Vec3
	}
}

var _ alias1.Float3Uniform = new(Float3UniformStub)

func (stub *Float3UniformStub) SetValue(arg1 alias2.Vec3) {
	stub.setValueMutex.Lock()
	defer stub.setValueMutex.Unlock()
	stub.setValueArgsForCall = append(stub.setValueArgsForCall, struct {
		arg1 alias2.Vec3
	}{arg1})
	if stub.SetValueStub != nil {
		stub.SetValueStub(arg1)
	}
}
func (stub *Float3UniformStub) SetValueCallCount() int {
	stub.setValueMutex.RLock()
	defer stub.setValueMutex.RUnlock()
	return len(stub.setValueArgsForCall)
}
func (stub *Float3UniformStub) SetValueArgsForCall(index int) alias2.Vec3 {
	stub.setValueMutex.RLock()
	defer stub.setValueMutex.RUnlock()
	return stub.setValueArgsForCall[index].arg1
}
func (stub *Float3UniformStub) Value() alias2.Vec3 {
	stub.valueMutex.Lock()
	defer stub.valueMutex.Unlock()
	stub.valueArgsForCall = append(stub.valueArgsForCall, struct {
	}{})
	if stub.ValueStub != nil {
		return stub.ValueStub()
	} else {
		return stub.valueReturns.result1
	}
}
func (stub *Float3UniformStub) ValueCallCount() int {
	stub.valueMutex.RLock()
	defer stub.valueMutex.RUnlock()
	return len(stub.valueArgsForCall)
}
func (stub *Float3UniformStub) ValueReturns(result1 alias2.Vec3) {
	stub.valueMutex.Lock()
	defer stub.valueMutex.Unlock()
	stub.valueReturns = struct {
		result1 alias2.Vec3
	}{result1}
}
