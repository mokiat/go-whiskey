// Generated by 'github.com/momchil-atanasov/gostub'

package graphics_stubs

import (
	sync "sync"

	alias1 "github.com/momchil-atanasov/go-whiskey/graphics"
	alias2 "github.com/momchil-atanasov/go-whiskey/math"
)

type RendererStub struct {
	InitializeStub        func() (result1 error)
	initializeMutex       sync.RWMutex
	initializeArgsForCall []struct {
	}
	initializeReturns struct {
		result1 error
	}
	UseMaterialStub        func(arg1 alias1.Material)
	useMaterialMutex       sync.RWMutex
	useMaterialArgsForCall []struct {
		arg1 alias1.Material
	}
	BindFloat2AttributeArrayStub        func(arg1 alias1.AttributeName, arg2 alias1.Float2AttributeArray)
	bindFloat2AttributeArrayMutex       sync.RWMutex
	bindFloat2AttributeArrayArgsForCall []struct {
		arg1 alias1.AttributeName
		arg2 alias1.Float2AttributeArray
	}
	BindFloat3AttributeArrayStub        func(arg1 alias1.AttributeName, arg2 alias1.Float3AttributeArray)
	bindFloat3AttributeArrayMutex       sync.RWMutex
	bindFloat3AttributeArrayArgsForCall []struct {
		arg1 alias1.AttributeName
		arg2 alias1.Float3AttributeArray
	}
	BindFloat4x4UniformStub        func(arg1 alias1.UniformName, arg2 alias2.Mat4x4)
	bindFloat4x4UniformMutex       sync.RWMutex
	bindFloat4x4UniformArgsForCall []struct {
		arg1 alias1.UniformName
		arg2 alias2.Mat4x4
	}
	BindFloat4UniformStub        func(arg1 alias1.UniformName, arg2 alias2.Vec4)
	bindFloat4UniformMutex       sync.RWMutex
	bindFloat4UniformArgsForCall []struct {
		arg1 alias1.UniformName
		arg2 alias2.Vec4
	}
	RenderStub        func(arg1 alias1.ElementType, arg2 alias1.IndexArray)
	renderMutex       sync.RWMutex
	renderArgsForCall []struct {
		arg1 alias1.ElementType
		arg2 alias1.IndexArray
	}
	FlushStub        func() (result1 error)
	flushMutex       sync.RWMutex
	flushArgsForCall []struct {
	}
	flushReturns struct {
		result1 error
	}
}

var _ alias1.Renderer = new(RendererStub)

func (stub *RendererStub) Initialize() error {
	stub.initializeMutex.Lock()
	defer stub.initializeMutex.Unlock()
	stub.initializeArgsForCall = append(stub.initializeArgsForCall, struct {
	}{})
	if stub.InitializeStub != nil {
		return stub.InitializeStub()
	} else {
		return stub.initializeReturns.result1
	}
}
func (stub *RendererStub) InitializeCallCount() int {
	stub.initializeMutex.RLock()
	defer stub.initializeMutex.RUnlock()
	return len(stub.initializeArgsForCall)
}
func (stub *RendererStub) InitializeReturns(result1 error) {
	stub.initializeMutex.Lock()
	defer stub.initializeMutex.Unlock()
	stub.initializeReturns = struct {
		result1 error
	}{result1}
}
func (stub *RendererStub) UseMaterial(arg1 alias1.Material) {
	stub.useMaterialMutex.Lock()
	defer stub.useMaterialMutex.Unlock()
	stub.useMaterialArgsForCall = append(stub.useMaterialArgsForCall, struct {
		arg1 alias1.Material
	}{arg1})
	if stub.UseMaterialStub != nil {
		stub.UseMaterialStub(arg1)
	}
}
func (stub *RendererStub) UseMaterialCallCount() int {
	stub.useMaterialMutex.RLock()
	defer stub.useMaterialMutex.RUnlock()
	return len(stub.useMaterialArgsForCall)
}
func (stub *RendererStub) UseMaterialArgsForCall(index int) alias1.Material {
	stub.useMaterialMutex.RLock()
	defer stub.useMaterialMutex.RUnlock()
	return stub.useMaterialArgsForCall[index].arg1
}
func (stub *RendererStub) BindFloat2AttributeArray(arg1 alias1.AttributeName, arg2 alias1.Float2AttributeArray) {
	stub.bindFloat2AttributeArrayMutex.Lock()
	defer stub.bindFloat2AttributeArrayMutex.Unlock()
	stub.bindFloat2AttributeArrayArgsForCall = append(stub.bindFloat2AttributeArrayArgsForCall, struct {
		arg1 alias1.AttributeName
		arg2 alias1.Float2AttributeArray
	}{arg1, arg2})
	if stub.BindFloat2AttributeArrayStub != nil {
		stub.BindFloat2AttributeArrayStub(arg1, arg2)
	}
}
func (stub *RendererStub) BindFloat2AttributeArrayCallCount() int {
	stub.bindFloat2AttributeArrayMutex.RLock()
	defer stub.bindFloat2AttributeArrayMutex.RUnlock()
	return len(stub.bindFloat2AttributeArrayArgsForCall)
}
func (stub *RendererStub) BindFloat2AttributeArrayArgsForCall(index int) (alias1.AttributeName, alias1.Float2AttributeArray) {
	stub.bindFloat2AttributeArrayMutex.RLock()
	defer stub.bindFloat2AttributeArrayMutex.RUnlock()
	return stub.bindFloat2AttributeArrayArgsForCall[index].arg1, stub.bindFloat2AttributeArrayArgsForCall[index].arg2
}
func (stub *RendererStub) BindFloat3AttributeArray(arg1 alias1.AttributeName, arg2 alias1.Float3AttributeArray) {
	stub.bindFloat3AttributeArrayMutex.Lock()
	defer stub.bindFloat3AttributeArrayMutex.Unlock()
	stub.bindFloat3AttributeArrayArgsForCall = append(stub.bindFloat3AttributeArrayArgsForCall, struct {
		arg1 alias1.AttributeName
		arg2 alias1.Float3AttributeArray
	}{arg1, arg2})
	if stub.BindFloat3AttributeArrayStub != nil {
		stub.BindFloat3AttributeArrayStub(arg1, arg2)
	}
}
func (stub *RendererStub) BindFloat3AttributeArrayCallCount() int {
	stub.bindFloat3AttributeArrayMutex.RLock()
	defer stub.bindFloat3AttributeArrayMutex.RUnlock()
	return len(stub.bindFloat3AttributeArrayArgsForCall)
}
func (stub *RendererStub) BindFloat3AttributeArrayArgsForCall(index int) (alias1.AttributeName, alias1.Float3AttributeArray) {
	stub.bindFloat3AttributeArrayMutex.RLock()
	defer stub.bindFloat3AttributeArrayMutex.RUnlock()
	return stub.bindFloat3AttributeArrayArgsForCall[index].arg1, stub.bindFloat3AttributeArrayArgsForCall[index].arg2
}
func (stub *RendererStub) BindFloat4x4Uniform(arg1 alias1.UniformName, arg2 alias2.Mat4x4) {
	stub.bindFloat4x4UniformMutex.Lock()
	defer stub.bindFloat4x4UniformMutex.Unlock()
	stub.bindFloat4x4UniformArgsForCall = append(stub.bindFloat4x4UniformArgsForCall, struct {
		arg1 alias1.UniformName
		arg2 alias2.Mat4x4
	}{arg1, arg2})
	if stub.BindFloat4x4UniformStub != nil {
		stub.BindFloat4x4UniformStub(arg1, arg2)
	}
}
func (stub *RendererStub) BindFloat4x4UniformCallCount() int {
	stub.bindFloat4x4UniformMutex.RLock()
	defer stub.bindFloat4x4UniformMutex.RUnlock()
	return len(stub.bindFloat4x4UniformArgsForCall)
}
func (stub *RendererStub) BindFloat4x4UniformArgsForCall(index int) (alias1.UniformName, alias2.Mat4x4) {
	stub.bindFloat4x4UniformMutex.RLock()
	defer stub.bindFloat4x4UniformMutex.RUnlock()
	return stub.bindFloat4x4UniformArgsForCall[index].arg1, stub.bindFloat4x4UniformArgsForCall[index].arg2
}
func (stub *RendererStub) BindFloat4Uniform(arg1 alias1.UniformName, arg2 alias2.Vec4) {
	stub.bindFloat4UniformMutex.Lock()
	defer stub.bindFloat4UniformMutex.Unlock()
	stub.bindFloat4UniformArgsForCall = append(stub.bindFloat4UniformArgsForCall, struct {
		arg1 alias1.UniformName
		arg2 alias2.Vec4
	}{arg1, arg2})
	if stub.BindFloat4UniformStub != nil {
		stub.BindFloat4UniformStub(arg1, arg2)
	}
}
func (stub *RendererStub) BindFloat4UniformCallCount() int {
	stub.bindFloat4UniformMutex.RLock()
	defer stub.bindFloat4UniformMutex.RUnlock()
	return len(stub.bindFloat4UniformArgsForCall)
}
func (stub *RendererStub) BindFloat4UniformArgsForCall(index int) (alias1.UniformName, alias2.Vec4) {
	stub.bindFloat4UniformMutex.RLock()
	defer stub.bindFloat4UniformMutex.RUnlock()
	return stub.bindFloat4UniformArgsForCall[index].arg1, stub.bindFloat4UniformArgsForCall[index].arg2
}
func (stub *RendererStub) Render(arg1 alias1.ElementType, arg2 alias1.IndexArray) {
	stub.renderMutex.Lock()
	defer stub.renderMutex.Unlock()
	stub.renderArgsForCall = append(stub.renderArgsForCall, struct {
		arg1 alias1.ElementType
		arg2 alias1.IndexArray
	}{arg1, arg2})
	if stub.RenderStub != nil {
		stub.RenderStub(arg1, arg2)
	}
}
func (stub *RendererStub) RenderCallCount() int {
	stub.renderMutex.RLock()
	defer stub.renderMutex.RUnlock()
	return len(stub.renderArgsForCall)
}
func (stub *RendererStub) RenderArgsForCall(index int) (alias1.ElementType, alias1.IndexArray) {
	stub.renderMutex.RLock()
	defer stub.renderMutex.RUnlock()
	return stub.renderArgsForCall[index].arg1, stub.renderArgsForCall[index].arg2
}
func (stub *RendererStub) Flush() error {
	stub.flushMutex.Lock()
	defer stub.flushMutex.Unlock()
	stub.flushArgsForCall = append(stub.flushArgsForCall, struct {
	}{})
	if stub.FlushStub != nil {
		return stub.FlushStub()
	} else {
		return stub.flushReturns.result1
	}
}
func (stub *RendererStub) FlushCallCount() int {
	stub.flushMutex.RLock()
	defer stub.flushMutex.RUnlock()
	return len(stub.flushArgsForCall)
}
func (stub *RendererStub) FlushReturns(result1 error) {
	stub.flushMutex.Lock()
	defer stub.flushMutex.Unlock()
	stub.flushReturns = struct {
		result1 error
	}{result1}
}
