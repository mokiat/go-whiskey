// This file was generated by counterfeiter
package buffer_fakes

import (
	"sync"

	"github.com/momchil-atanasov/go-whiskey/graphics/buffer"
)

type FakeIndexBufferData struct {
	SetValueStub        func(position int, value uint16)
	setValueMutex       sync.RWMutex
	setValueArgsForCall []struct {
		position int
		value    uint16
	}
	ValueStub        func(position int) uint16
	valueMutex       sync.RWMutex
	valueArgsForCall []struct {
		position int
	}
	valueReturns struct {
		result1 uint16
	}
	SizeStub        func() int
	sizeMutex       sync.RWMutex
	sizeArgsForCall []struct{}
	sizeReturns struct {
		result1 int
	}
	ContentStub        func() []byte
	contentMutex       sync.RWMutex
	contentArgsForCall []struct{}
	contentReturns struct {
		result1 []byte
	}
}

func (fake *FakeIndexBufferData) SetValue(position int, value uint16) {
	fake.setValueMutex.Lock()
	fake.setValueArgsForCall = append(fake.setValueArgsForCall, struct {
		position int
		value    uint16
	}{position, value})
	fake.setValueMutex.Unlock()
	if fake.SetValueStub != nil {
		fake.SetValueStub(position, value)
	}
}

func (fake *FakeIndexBufferData) SetValueCallCount() int {
	fake.setValueMutex.RLock()
	defer fake.setValueMutex.RUnlock()
	return len(fake.setValueArgsForCall)
}

func (fake *FakeIndexBufferData) SetValueArgsForCall(i int) (int, uint16) {
	fake.setValueMutex.RLock()
	defer fake.setValueMutex.RUnlock()
	return fake.setValueArgsForCall[i].position, fake.setValueArgsForCall[i].value
}

func (fake *FakeIndexBufferData) Value(position int) uint16 {
	fake.valueMutex.Lock()
	fake.valueArgsForCall = append(fake.valueArgsForCall, struct {
		position int
	}{position})
	fake.valueMutex.Unlock()
	if fake.ValueStub != nil {
		return fake.ValueStub(position)
	} else {
		return fake.valueReturns.result1
	}
}

func (fake *FakeIndexBufferData) ValueCallCount() int {
	fake.valueMutex.RLock()
	defer fake.valueMutex.RUnlock()
	return len(fake.valueArgsForCall)
}

func (fake *FakeIndexBufferData) ValueArgsForCall(i int) int {
	fake.valueMutex.RLock()
	defer fake.valueMutex.RUnlock()
	return fake.valueArgsForCall[i].position
}

func (fake *FakeIndexBufferData) ValueReturns(result1 uint16) {
	fake.ValueStub = nil
	fake.valueReturns = struct {
		result1 uint16
	}{result1}
}

func (fake *FakeIndexBufferData) Size() int {
	fake.sizeMutex.Lock()
	fake.sizeArgsForCall = append(fake.sizeArgsForCall, struct{}{})
	fake.sizeMutex.Unlock()
	if fake.SizeStub != nil {
		return fake.SizeStub()
	} else {
		return fake.sizeReturns.result1
	}
}

func (fake *FakeIndexBufferData) SizeCallCount() int {
	fake.sizeMutex.RLock()
	defer fake.sizeMutex.RUnlock()
	return len(fake.sizeArgsForCall)
}

func (fake *FakeIndexBufferData) SizeReturns(result1 int) {
	fake.SizeStub = nil
	fake.sizeReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeIndexBufferData) Content() []byte {
	fake.contentMutex.Lock()
	fake.contentArgsForCall = append(fake.contentArgsForCall, struct{}{})
	fake.contentMutex.Unlock()
	if fake.ContentStub != nil {
		return fake.ContentStub()
	} else {
		return fake.contentReturns.result1
	}
}

func (fake *FakeIndexBufferData) ContentCallCount() int {
	fake.contentMutex.RLock()
	defer fake.contentMutex.RUnlock()
	return len(fake.contentArgsForCall)
}

func (fake *FakeIndexBufferData) ContentReturns(result1 []byte) {
	fake.ContentStub = nil
	fake.contentReturns = struct {
		result1 []byte
	}{result1}
}

var _ buffer.IndexBufferData = new(FakeIndexBufferData)
