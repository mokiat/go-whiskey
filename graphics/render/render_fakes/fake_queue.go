// This file was generated by counterfeiter
package render_fakes

import (
	"sync"

	"github.com/momchil-atanasov/go-whiskey/graphics/render"
)

type FakeQueue struct {
	EmptyStub        func() bool
	emptyMutex       sync.RWMutex
	emptyArgsForCall []struct{}
	emptyReturns struct {
		result1 bool
	}
	SizeStub        func() int
	sizeMutex       sync.RWMutex
	sizeArgsForCall []struct{}
	sizeReturns struct {
		result1 int
	}
	PushStub        func(render.Item)
	pushMutex       sync.RWMutex
	pushArgsForCall []struct {
		arg1 render.Item
	}
	PopStub        func() (render.Item, bool)
	popMutex       sync.RWMutex
	popArgsForCall []struct{}
	popReturns struct {
		result1 render.Item
		result2 bool
	}
}

func (fake *FakeQueue) Empty() bool {
	fake.emptyMutex.Lock()
	fake.emptyArgsForCall = append(fake.emptyArgsForCall, struct{}{})
	fake.emptyMutex.Unlock()
	if fake.EmptyStub != nil {
		return fake.EmptyStub()
	} else {
		return fake.emptyReturns.result1
	}
}

func (fake *FakeQueue) EmptyCallCount() int {
	fake.emptyMutex.RLock()
	defer fake.emptyMutex.RUnlock()
	return len(fake.emptyArgsForCall)
}

func (fake *FakeQueue) EmptyReturns(result1 bool) {
	fake.EmptyStub = nil
	fake.emptyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeQueue) Size() int {
	fake.sizeMutex.Lock()
	fake.sizeArgsForCall = append(fake.sizeArgsForCall, struct{}{})
	fake.sizeMutex.Unlock()
	if fake.SizeStub != nil {
		return fake.SizeStub()
	} else {
		return fake.sizeReturns.result1
	}
}

func (fake *FakeQueue) SizeCallCount() int {
	fake.sizeMutex.RLock()
	defer fake.sizeMutex.RUnlock()
	return len(fake.sizeArgsForCall)
}

func (fake *FakeQueue) SizeReturns(result1 int) {
	fake.SizeStub = nil
	fake.sizeReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeQueue) Push(arg1 render.Item) {
	fake.pushMutex.Lock()
	fake.pushArgsForCall = append(fake.pushArgsForCall, struct {
		arg1 render.Item
	}{arg1})
	fake.pushMutex.Unlock()
	if fake.PushStub != nil {
		fake.PushStub(arg1)
	}
}

func (fake *FakeQueue) PushCallCount() int {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	return len(fake.pushArgsForCall)
}

func (fake *FakeQueue) PushArgsForCall(i int) render.Item {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	return fake.pushArgsForCall[i].arg1
}

func (fake *FakeQueue) Pop() (render.Item, bool) {
	fake.popMutex.Lock()
	fake.popArgsForCall = append(fake.popArgsForCall, struct{}{})
	fake.popMutex.Unlock()
	if fake.PopStub != nil {
		return fake.PopStub()
	} else {
		return fake.popReturns.result1, fake.popReturns.result2
	}
}

func (fake *FakeQueue) PopCallCount() int {
	fake.popMutex.RLock()
	defer fake.popMutex.RUnlock()
	return len(fake.popArgsForCall)
}

func (fake *FakeQueue) PopReturns(result1 render.Item, result2 bool) {
	fake.PopStub = nil
	fake.popReturns = struct {
		result1 render.Item
		result2 bool
	}{result1, result2}
}

var _ render.Queue = new(FakeQueue)
