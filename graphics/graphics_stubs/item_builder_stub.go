// Generated by 'github.com/mokiat/gostub'

package graphics_stubs

import (
	sync "sync"

	alias1 "github.com/mokiat/go-whiskey/graphics"
)

type ItemBuilderStub struct {
	StubGUID         int
	BeginStub        func(arg1 alias1.Material, arg2 alias1.MaterialFilter) (result1 alias1.ItemBuilder)
	beginMutex       sync.RWMutex
	beginArgsForCall []struct {
		arg1 alias1.Material
		arg2 alias1.MaterialFilter
	}
	beginReturns struct {
		result1 alias1.ItemBuilder
	}
	SetDepthStub        func(arg1 int) (result1 alias1.ItemBuilder)
	setDepthMutex       sync.RWMutex
	setDepthArgsForCall []struct {
		arg1 int
	}
	setDepthReturns struct {
		result1 alias1.ItemBuilder
	}
	SetAttributeStub        func(arg1 alias1.AttributeName, arg2 alias1.AttributeArray) (result1 alias1.ItemBuilder)
	setAttributeMutex       sync.RWMutex
	setAttributeArgsForCall []struct {
		arg1 alias1.AttributeName
		arg2 alias1.AttributeArray
	}
	setAttributeReturns struct {
		result1 alias1.ItemBuilder
	}
	SetUniformStub        func(arg1 alias1.UniformName, arg2 alias1.Uniform) (result1 alias1.ItemBuilder)
	setUniformMutex       sync.RWMutex
	setUniformArgsForCall []struct {
		arg1 alias1.UniformName
		arg2 alias1.Uniform
	}
	setUniformReturns struct {
		result1 alias1.ItemBuilder
	}
	SetTextureStub        func(arg1 alias1.TextureName, arg2 alias1.Texture) (result1 alias1.ItemBuilder)
	setTextureMutex       sync.RWMutex
	setTextureArgsForCall []struct {
		arg1 alias1.TextureName
		arg2 alias1.Texture
	}
	setTextureReturns struct {
		result1 alias1.ItemBuilder
	}
	SetIndicesStub        func(arg1 alias1.IndexArray) (result1 alias1.ItemBuilder)
	setIndicesMutex       sync.RWMutex
	setIndicesArgsForCall []struct {
		arg1 alias1.IndexArray
	}
	setIndicesReturns struct {
		result1 alias1.ItemBuilder
	}
	EndStub        func(arg1 alias1.SequenceType, arg2 int, arg3 int) (result1 error)
	endMutex       sync.RWMutex
	endArgsForCall []struct {
		arg1 alias1.SequenceType
		arg2 int
		arg3 int
	}
	endReturns struct {
		result1 error
	}
}

var _ alias1.ItemBuilder = new(ItemBuilderStub)

func (stub *ItemBuilderStub) Begin(arg1 alias1.Material, arg2 alias1.MaterialFilter) alias1.ItemBuilder {
	stub.beginMutex.Lock()
	defer stub.beginMutex.Unlock()
	stub.beginArgsForCall = append(stub.beginArgsForCall, struct {
		arg1 alias1.Material
		arg2 alias1.MaterialFilter
	}{arg1, arg2})
	if stub.BeginStub != nil {
		return stub.BeginStub(arg1, arg2)
	} else {
		return stub.beginReturns.result1
	}
}
func (stub *ItemBuilderStub) BeginCallCount() int {
	stub.beginMutex.RLock()
	defer stub.beginMutex.RUnlock()
	return len(stub.beginArgsForCall)
}
func (stub *ItemBuilderStub) BeginArgsForCall(index int) (alias1.Material, alias1.MaterialFilter) {
	stub.beginMutex.RLock()
	defer stub.beginMutex.RUnlock()
	return stub.beginArgsForCall[index].arg1, stub.beginArgsForCall[index].arg2
}
func (stub *ItemBuilderStub) BeginReturns(result1 alias1.ItemBuilder) {
	stub.beginMutex.Lock()
	defer stub.beginMutex.Unlock()
	stub.beginReturns = struct {
		result1 alias1.ItemBuilder
	}{result1}
}
func (stub *ItemBuilderStub) SetDepth(arg1 int) alias1.ItemBuilder {
	stub.setDepthMutex.Lock()
	defer stub.setDepthMutex.Unlock()
	stub.setDepthArgsForCall = append(stub.setDepthArgsForCall, struct {
		arg1 int
	}{arg1})
	if stub.SetDepthStub != nil {
		return stub.SetDepthStub(arg1)
	} else {
		return stub.setDepthReturns.result1
	}
}
func (stub *ItemBuilderStub) SetDepthCallCount() int {
	stub.setDepthMutex.RLock()
	defer stub.setDepthMutex.RUnlock()
	return len(stub.setDepthArgsForCall)
}
func (stub *ItemBuilderStub) SetDepthArgsForCall(index int) int {
	stub.setDepthMutex.RLock()
	defer stub.setDepthMutex.RUnlock()
	return stub.setDepthArgsForCall[index].arg1
}
func (stub *ItemBuilderStub) SetDepthReturns(result1 alias1.ItemBuilder) {
	stub.setDepthMutex.Lock()
	defer stub.setDepthMutex.Unlock()
	stub.setDepthReturns = struct {
		result1 alias1.ItemBuilder
	}{result1}
}
func (stub *ItemBuilderStub) SetAttribute(arg1 alias1.AttributeName, arg2 alias1.AttributeArray) alias1.ItemBuilder {
	stub.setAttributeMutex.Lock()
	defer stub.setAttributeMutex.Unlock()
	stub.setAttributeArgsForCall = append(stub.setAttributeArgsForCall, struct {
		arg1 alias1.AttributeName
		arg2 alias1.AttributeArray
	}{arg1, arg2})
	if stub.SetAttributeStub != nil {
		return stub.SetAttributeStub(arg1, arg2)
	} else {
		return stub.setAttributeReturns.result1
	}
}
func (stub *ItemBuilderStub) SetAttributeCallCount() int {
	stub.setAttributeMutex.RLock()
	defer stub.setAttributeMutex.RUnlock()
	return len(stub.setAttributeArgsForCall)
}
func (stub *ItemBuilderStub) SetAttributeArgsForCall(index int) (alias1.AttributeName, alias1.AttributeArray) {
	stub.setAttributeMutex.RLock()
	defer stub.setAttributeMutex.RUnlock()
	return stub.setAttributeArgsForCall[index].arg1, stub.setAttributeArgsForCall[index].arg2
}
func (stub *ItemBuilderStub) SetAttributeReturns(result1 alias1.ItemBuilder) {
	stub.setAttributeMutex.Lock()
	defer stub.setAttributeMutex.Unlock()
	stub.setAttributeReturns = struct {
		result1 alias1.ItemBuilder
	}{result1}
}
func (stub *ItemBuilderStub) SetUniform(arg1 alias1.UniformName, arg2 alias1.Uniform) alias1.ItemBuilder {
	stub.setUniformMutex.Lock()
	defer stub.setUniformMutex.Unlock()
	stub.setUniformArgsForCall = append(stub.setUniformArgsForCall, struct {
		arg1 alias1.UniformName
		arg2 alias1.Uniform
	}{arg1, arg2})
	if stub.SetUniformStub != nil {
		return stub.SetUniformStub(arg1, arg2)
	} else {
		return stub.setUniformReturns.result1
	}
}
func (stub *ItemBuilderStub) SetUniformCallCount() int {
	stub.setUniformMutex.RLock()
	defer stub.setUniformMutex.RUnlock()
	return len(stub.setUniformArgsForCall)
}
func (stub *ItemBuilderStub) SetUniformArgsForCall(index int) (alias1.UniformName, alias1.Uniform) {
	stub.setUniformMutex.RLock()
	defer stub.setUniformMutex.RUnlock()
	return stub.setUniformArgsForCall[index].arg1, stub.setUniformArgsForCall[index].arg2
}
func (stub *ItemBuilderStub) SetUniformReturns(result1 alias1.ItemBuilder) {
	stub.setUniformMutex.Lock()
	defer stub.setUniformMutex.Unlock()
	stub.setUniformReturns = struct {
		result1 alias1.ItemBuilder
	}{result1}
}
func (stub *ItemBuilderStub) SetTexture(arg1 alias1.TextureName, arg2 alias1.Texture) alias1.ItemBuilder {
	stub.setTextureMutex.Lock()
	defer stub.setTextureMutex.Unlock()
	stub.setTextureArgsForCall = append(stub.setTextureArgsForCall, struct {
		arg1 alias1.TextureName
		arg2 alias1.Texture
	}{arg1, arg2})
	if stub.SetTextureStub != nil {
		return stub.SetTextureStub(arg1, arg2)
	} else {
		return stub.setTextureReturns.result1
	}
}
func (stub *ItemBuilderStub) SetTextureCallCount() int {
	stub.setTextureMutex.RLock()
	defer stub.setTextureMutex.RUnlock()
	return len(stub.setTextureArgsForCall)
}
func (stub *ItemBuilderStub) SetTextureArgsForCall(index int) (alias1.TextureName, alias1.Texture) {
	stub.setTextureMutex.RLock()
	defer stub.setTextureMutex.RUnlock()
	return stub.setTextureArgsForCall[index].arg1, stub.setTextureArgsForCall[index].arg2
}
func (stub *ItemBuilderStub) SetTextureReturns(result1 alias1.ItemBuilder) {
	stub.setTextureMutex.Lock()
	defer stub.setTextureMutex.Unlock()
	stub.setTextureReturns = struct {
		result1 alias1.ItemBuilder
	}{result1}
}
func (stub *ItemBuilderStub) SetIndices(arg1 alias1.IndexArray) alias1.ItemBuilder {
	stub.setIndicesMutex.Lock()
	defer stub.setIndicesMutex.Unlock()
	stub.setIndicesArgsForCall = append(stub.setIndicesArgsForCall, struct {
		arg1 alias1.IndexArray
	}{arg1})
	if stub.SetIndicesStub != nil {
		return stub.SetIndicesStub(arg1)
	} else {
		return stub.setIndicesReturns.result1
	}
}
func (stub *ItemBuilderStub) SetIndicesCallCount() int {
	stub.setIndicesMutex.RLock()
	defer stub.setIndicesMutex.RUnlock()
	return len(stub.setIndicesArgsForCall)
}
func (stub *ItemBuilderStub) SetIndicesArgsForCall(index int) alias1.IndexArray {
	stub.setIndicesMutex.RLock()
	defer stub.setIndicesMutex.RUnlock()
	return stub.setIndicesArgsForCall[index].arg1
}
func (stub *ItemBuilderStub) SetIndicesReturns(result1 alias1.ItemBuilder) {
	stub.setIndicesMutex.Lock()
	defer stub.setIndicesMutex.Unlock()
	stub.setIndicesReturns = struct {
		result1 alias1.ItemBuilder
	}{result1}
}
func (stub *ItemBuilderStub) End(arg1 alias1.SequenceType, arg2 int, arg3 int) error {
	stub.endMutex.Lock()
	defer stub.endMutex.Unlock()
	stub.endArgsForCall = append(stub.endArgsForCall, struct {
		arg1 alias1.SequenceType
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	if stub.EndStub != nil {
		return stub.EndStub(arg1, arg2, arg3)
	} else {
		return stub.endReturns.result1
	}
}
func (stub *ItemBuilderStub) EndCallCount() int {
	stub.endMutex.RLock()
	defer stub.endMutex.RUnlock()
	return len(stub.endArgsForCall)
}
func (stub *ItemBuilderStub) EndArgsForCall(index int) (alias1.SequenceType, int, int) {
	stub.endMutex.RLock()
	defer stub.endMutex.RUnlock()
	return stub.endArgsForCall[index].arg1, stub.endArgsForCall[index].arg2, stub.endArgsForCall[index].arg3
}
func (stub *ItemBuilderStub) EndReturns(result1 error) {
	stub.endMutex.Lock()
	defer stub.endMutex.Unlock()
	stub.endReturns = struct {
		result1 error
	}{result1}
}
